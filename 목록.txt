bfs
1. 숨바꼭질 (백준 1697번) o
  -> 값이 같은 경우 -1, +1를 해서 최단거리가 2가 나오는 경우의 처리를 하지 않음.
2. 숨바꼭질(백준 12851번) o
  -> 1번 문제에서 경로의 갯수를 더하는 배열을 하나 더 만든다.
  -> 한번 더 방문을 하는 경우는 그 전 경우를 더한다.
  -> 아기상어 문제와 이어진다. 
  -> 다른 경로에서 접근시에 처리하는 방법 : 아기상어문제 (최단경로 여러개를 가지고)
3. 숨바꼭질 (백준 13549번) x
   -> 간선의 가중치가 다른 경우에는 bfs를 사용할 수 없다.
   -> 방법 1 . 0,1 bfs
   -> 다익스트라
   -> 아직 잘 모르겠다.
 
4. 숨바꼭질 (백준 13913번) o
  -> 1번 문제에서 경로를 추가한다. 경로를 출력시 위상정렬를 이용하거나 그냥 벡터에서 넣음
5. 미로 탐색(백준 2178번) o
  -> 기본적인 bfs 문제.1이면 갈수 있게 구현하면 됨.
6. 벽 부수고 이동하기 (백준 2206번) 
  -> 시간 초과 문제 발생.
  -> 현재 벽을 하나 부수고 다시 최단거리를 구함 (얘를 여러번 반복) 
  -> 
7. 스타트링크 (백준 5014번) 0
  -> 최단거리를 구하는 bfs이다. 
  -> 경로를 구할때에는 이전꺼랑 +1 차이가 난다면 경로의 갯수를 더할 수 있다. (아기상어는 최단거리일때 갯수를 모두 더한 뒤 비교를 해서 만든다.)

8. 탈출 문제 (백준 3055번) o
   -> bfs를 돌리는 데 큐를 두개 넣어서 돌린다.
   -> 변수가 너무 많아서 헷갈린다
   -> 돌을 처리하는 걸 빼먹어서 내일 다시 해야한다.
   -> bfs에 큐를 두개 넣어서 돌리는데, visited[]의 크기에 따라서 탈출을 해서 같은 depth 만 가게끔 만들었다.
   -> 위에 이야기한 것 처럼 처리하면 생각보다 복잡한데, depth 별로 bfs를 진행할 수 있는 걸 배웟다.
   -> detpt 별로 진행하는 건 사실 의미없고, 초기 물에 대한 dfs를 모두 돌려서 물이 몇시에 들어오는 지를 모두 저장한 다음 고슴도치가 가면서 물이 언제 들어와있는지를 판단하면서 처리하는게 더 쉽다.
   -> 코드 리뷰 부탁함(친구한테)
   -> 내가 생각한 방법에 확신을 가져야 한다고 생각한 문제.

9. DSLR (백준 9019번)
  -> 전형적인 bfs 문제 q의 타입을 <int><string>
  -> string 에서 메모리 초과가 난다고 하는데 나는 나지 않음.
  

   
dfs 
1. 모든 순열(백준 10974번) o
   -> 기본적인 dfs 문제 재귀함수를 이용해서 재귀함수 이전에 방문 재귀함수 나올때 다시 초기화를 해주면서 모든 경우를 탐색한다. 
   -> endl 은 시간초가를 유발할 수 있다.
3. 1,2,3 더하기 (백준 9095번) o
    -> 기본적인 dfs 문제에서 탈출 조건을 잘 하면 바로 풀 수 있는 문제.
4. 암호만들기 (백준 1759번) o
    -> 기본적인 dfs 문제로 2의 n승의 경우를 모두 탐색
    -> ex void dfs(int cnt)
          {  벡터에 하나 추가 // dfs (cnt+1) // 벡터에 하나 삭제 dfs (cnt) //};
    -> 계속 visited를 써서 헷갈릴수도 있는데 파라미터를 넘길때 벡터만 넘겨서 사이즈로 판단.

5. nqueen 문제(백준 알고리즘) o
    -> 백트리킹 문제이다. 나는 백트래킹을 bfs에서 유망함수에 의해서 상황에 따라 덜 재귀함수를 도는 걸로 알고 있는데, 못풀겠다.
    -> promising 함수를 적절히 만든다면 금방 풀수 있다.
    -> 백트래킹이라고 하는데 
    -> promising 함수는 분기별로 들어갈지 말지를 판단하는 함수이지 백트래킹이랑은 상관은 없는 거같다.
    -> 한 경우에 대해서 깊게 들어 갈 시에 실패하면 이전껄로 돌아와서 하는 걸 백트래킹이라고 하는데, 구현상에서는 visited[i] = 0 으로 처리하는 것을 의미하지만 구현상 따로 해줄 필요는 없는 거 같음.
    -> 품 (06.23)
    
6. 알파벳 문제 (백준 1987번) x o 
    -> 모든 경우를 처리했다고 생각했는데 틀렷다고 나온다. 내일 다시 확인 필요
    -> bfs에서 변수로 vector를 모두 넘기면 시간 초과가 나온다. 대신 배열을 넘길 생각을 했는데, bfs 들어가기 전, 후 처리를 잘한다면 전역변수로 지정해서 사용해도 별 무리가 없을듯 하다.
    
7. 부분수열의 합 (백준 1182번) o
     -> 처음 생각 start, end 까지 해서 합을 만들면 된다고 생각
     -> 각 값들의 범위가 크기 때문에 재귀 함수를 쓰자 ?
     -> bfs에 대한 개념은 확실히 있는 거 같은데, 함수가 탈출한  경우에 대한 생각이 모자란거같음. ()
8. 종이 조각 (백준 14391번) x
     -> 비트마스크 ?
     -> 1. 개념은 모든경우에 대해서 dfs를 돌린다. (백 트래킹 ? 어떤 식으로 백트래킹을 쓸까 ?)
     -> 아직 못풀겠음 (비트마스크가 들어가서 잘 안해본 문제라서 그런듯 시간이 필요.)

     
     
번외 문제
1. 이분그래프 (백준1707번) 0
   -> 이분그래프를 판단하는 것, dfs(int, cnt) -> 함수에 들어갈 수록 cnt+1 를 넣어서 홀짝홀짝해서 만든다.
   -> 어디서 오류가 나는지는 찾지 못했다.
   -> for문안에 변수를 잘못 설정했다.
2. Two Dots (백준 16929번) o 
    -> 사이클을 찾는 문제
    -> cnt 로 둬서 바로 돌아가는 경우를 처리했다
    -> dfs 로 모든경우를 탐색하려 했으나 return 값이 되는 부분이 내가 생각하는 것과는 다르게 실행 되어서 전역변수를 준다음 처리했다. 
    -> 깔끔하지는 않은듯.
    
