bfs
1. 숨바꼭질 (백준 1697번) o
  -> 값이 같은 경우 -1, +1를 해서 최단거리가 2가 나오는 경우의 처리를 하지 않음.
2. 숨바꼭질(백준 12851번) o
  -> 1번 문제에서 경로의 갯수를 더하는 배열을 하나 더 만든다.
  -> 한번 더 방문을 하는 경우는 그 전 경우를 더한다.
4. 숨바꼭질 (백준 13913번) o
  -> 1번 문제에서 경로를 추가한다. 경로를 출력시 위상정렬를 이용하거나 그냥 벡터에서 넣음
5. 미로 탐색(백준 2178번) o
  -> 기본적인 bfs 문제.1이면 갈수 있게 구현하면 됨.
6. 벽 부수고 이동하기 (백준 2206번)
  -> 시간 초과 문제 발생.
  -> 현재 벽을 하나 부수고 다시 최단거리를 구함 (얘를 여러번 반복) 
  -> 

dfs 
1. 모든 순열(백준 10974번) o
   -> 기본적인 dfs 문제 재귀함수를 이용해서 재귀함수 이전에 방문 재귀함수 나올때 다시 초기화를 해주면서 모든 경우를 탐색한다. 
   -> endl 은 시간초가를 유발할 수 있다.
3. 1,2,3 더하기 (백준 9095번) o
    -> 기본적인 dfs 문제에서 탈출 조건을 잘 하면 바로 풀 수 있는 문제.
4. 암호만들기 (백준 1759번) o
    -> 기본적인 dfs 문제로 2의 n승의 경우를 모두 탐색
    -> ex void dfs(int cnt)
          {  벡터에 하나 추가 // dfs (cnt+1) // 벡터에 하나 삭제 dfs (cnt) //};
    -> 계속 visited를 써서 헷갈릴수도 있는데 파라미터를 넘길때 벡터만 넘겨서 사이즈로 판단.

5. nqueen 문제(백준 알고리즘) o
    -> 백트리킹 문제이다. 나는 백트래킹을 bfs에서 유망함수에 의해서 상황에 따라 덜 재귀함수를 도는 걸로 알고 있는데, 못풀겠다.
    -> promising 함수를 적절히 만든다면 금방 풀수 있다.
    -> 백트래킹이라고 하는데 
    -> promising 함수는 분기별로 들어갈지 말지를 판단하는 함수이지 백트래킹이랑은 상관은 없는 거같다.
    -> 한 경우에 대해서 깊게 들어 갈 시에 실패하면 이전껄로 돌아와서 하는 걸 백트래킹이라고 하는데, 구현상에서는 visited[i] = 0 으로 처리하는 것을 의미하지만 구현상 따로 해줄 필요는 없는 거 같음.
    -> 품 (06.23)
    
6. 알파벳 문제 (백준 1987번) x o 
    -> 모든 경우를 처리했다고 생각했는데 틀렷다고 나온다. 내일 다시 확인 필요
    -> bfs에서 변수로 vector를 모두 넘기면 시간 초과가 나온다. 대신 배열을 넘길 생각을 했는데, bfs 들어가기 전, 후 처리를 잘한다면 전역변수로 지정해서 사용해도 별 무리가 없을듯 하다.
    
7. 부분수열의 합 (백준 1182번) o
     -> 처음 생각 start, end 까지 해서 합을 만들면 된다고 생각
     -> 각 값들의 범위가 크기 때문에 재귀 함수를 쓰자 ?
     -> bfs에 대한 개념은 확실히 있는 거 같은데, 함수가 탈출한  경우에 대한 생각이 모자란거같음. ()
     
